---
title: 全干工程师：后端工程师入坑前端总结
---

> 🎊 2022 年了，作为一个后端工程师，如何入坑前端，成为全干程师。 本文以做一个共享购物车的 Web 端为目标，从框架选型，配套工具链，编程语言语法，CSS 样式等等，涉及做一个前端项目的方方面面，啥都整一点，再次入坑前端，以主观视角总结一下。

## **框架及工具链选型**

其实我在几年之前也入坑过前端，用过 Angular 写过用于接口测试的工具，也因此被领导作为**幸运儿**选中，将已有的一个用 Delphi 写的金融后台管理系统搬到浏览器上。Angular 在前端三驾马车(React/Vue/Angular)里面好像一直不太受待见，作为已经弃坑的人，个人评价是 Angular 是为为框架区别于 React/Vue 的，选择了 Angular，也即绑定了相应的工具链，自由度也低很多，同时 Angular 也开箱即用的附带一套完整的工程实践，没有什么 Redux, Vuex 等等。这对新手快速入门写出可以上线的系统还是有好处的，坏处则是 `TOO HEAVY` 了，运行起来也能明显感觉到延迟，有很多现成的组件可以用，包括阴影爱好者 **Material UI** 也算是官方出品的，但是要自定义这些组件的逻辑或格式基本上就不可能了。

之前弃坑主要的原因是前端工具链太庞杂了，包括浏览器令人恐惧的适配问题，繁多的 JavaScript 版本(ES5, ES6, ESnext, ES2015...)；也整出了 Babel 这种将高版本 JS 语法代码编译成适配旧浏览器的低版本运行环时的编译器；用 polyfill 适配不同厂商的浏览器；而 Node.js 的包管理工具就有 npm, pnpm, yarn，配合 960 万平方公里的局域网，下载依赖等个半小时然后 **TIMEOUT** 也是时不时的事，顺便吐槽一下 Node.js 包的海量小文件简直是机械硬盘杀手；也有大佬 `Anders Hejlsberg` 发明了 TypeScript 来克服 JS 动态类型的安全问题和大型工程的开发效率问题；在 CSS 预处理器领域，也有诸如 LESS, Sass, Stylus 等工具；最后 JS 模块化也有 CommonJS 和 ESModule，视运行环境和 Node.js 版本决定那种方式可用或者混用。

此次重新入坑，主要是有了 [2022 年 JavaScript 开发工具的生态，别再用过时的框架了！](https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651609107&idx=1&sn=1a9852c5b75c93a2cfe1cc75976fbc7e&chksm=80228fd2b75506c44d2f94f73f9652f651c5d4365301e4d373dbc3c0f2184bdae32ba1098bc2&mpshare=1&scene=24&srcid=09238KcKE3NPB3HxIRImkCo4&sharer_sharetime=1663948292152&sharer_shareid=d191ad3ea6161ade592a68edc02f9535&ascene=14&devicetype=android-31&version=28001e3b&nettype=cmnet&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&exportkey=n_ChQIAhIQtK9XFWnaA9nNrCM6YFHrYBLUAQIE97dBBAEAAAAAAIvbLx6IupgAAAAOpnltbLcz9gKNyK89dVj0jrfbZOYUGpax4YX7W1xPTnbulD0xNQ09pvXnOvYl7beiIh%2BRPcgnFaEKARnL0UwtRmQnUmlwKS5pnkIW6IdI6i8t5PS6u8dtXx1L%2FofecJmt9wQmkg8iVnt%2BCOWrVzgLZfbeKs0DdB9eaqtAlYhidXcMf0UUqDT06Oi2ij%2FNfuywdg6FhpSBZ4LYjbF%2BE1S6eHDaSlBJupZRjWQN1DVOVKeZahdxHDrxb7%2F8jDrx&pass_ticket=2grPXiaE0KbjA299f%2BV%2BWy9Qa8u1oG7Vmc%2Bh%2B%2FDkP7zDL%2FBdwgJmMr2KQZ8AmbdO&wx_header=3) 这篇文章作为参考，轻松选择了 React.js + Next.js + TailwindCSS + axios 等来构建应用。另一个参考的是 [Frontend Developer Roadmap](https://roadmap.sh/frontend)，用路线图的方式解构了前端开发的方方面面，对于前端知识框架的查漏补缺非常有帮助。

### **React.js**

上次学习 [React.js](https://reactjs.org/) 学到在 Class Component 里面写 `this.deleteRow.bind(this, id)` 这种代码的时候就被劝退了。React 16.8 引入 [Hooks](https://reactjs.org/docs/hooks-intro.html) 之后，算是消除了这个担忧 😟。

### **Next.js**

[Next.js](https://nextjs.org/docs/getting-started) 是构建在 React.js 上的前端开发框架，集成了编译器，CSS 预处理，路由等等，大大简化了前端工程化的问题，同时还引入了 SSR, SSG 等高级特性；使前端应用不再仅仅是运行在浏览器上面的单页面应用，也可以有对应的后端，最近来推出了号称比 `WebPack` 快 "**700倍**" 的 TurboPack。

### **TailwindCSS**

[Tailwind](https://tailwindui.com/) 提供一套标准的，风格一致的 CSS 样式集合，可以完全不写一行 CSS 代码，只通过 class 的组合实现的丰富的视觉样式；从有限的集合中选取可用的 `class name` 一方面可以保证风格一致，另一方面可以方便样式的管理，不至于像每个页面单独写一个 CSS 文件混乱分散，定义各种蹩脚的 class name；最后，TailwindCSS 配合 PostCSS 具，可以自动扫描项目中用到的 `class name` 输出一个用到的样式集合 CSS 文件，减少构建产物的体积，提高页面加载速度。

## **JavaScript & Node.js**

> 本节介绍一些项目中必须要理解又容易被忽略的基本概念，导致新手（指我🥺）在开发过程中很容易知其然，不知其所以然。

### **JavaScript Modules**

最初版本的 JavaScript 被设计成运行在浏览器中，通常是内嵌在 HTML 页面中的 `<script />` 代码，通过同步或异步的方式加载，并没有模块的概念，所有变量，常量，函数是全局可见的；这显然限制了前端的工程化。参考文档：[CommonJS vs. ES Modules: Modules and Imports in NodeJS](https://reflectoring.io/nodejs-modules-imports/) .

#### **CommonJS Modules**

在 `CommonJS Module` 模式下，每一个 `.js` 文件都是一个模块，通过 `module.exports` 导出文件中的 `symbol`，换言之，其它非导出的变量，常量，函数等，外部不可直接引用。

``` js
// file bar.js
const message = "Hello, world!"; // 模块外不可见
const greeting = () => {
    console.log(message);
}

module.exports = { greeting }; // 导出函数 bar
```

`module.exports` 可以简写成 `exports`，因此 `bar.js` 中的导出表达式也有对应的写法。

``` js
#1
exports.greeting = greeting;
#2
exports.hello = greeting; // 将 greeting 以 hello 我名字导出
#3
exports = {
    hello: greeting, // 与 #2 等价
}
```

通过 `require` 导入其它模块

``` js
// file foo.js
const bar = require("bar"); // 导入 bar.js 模块，模块名为去掉了后缀的文件名
bar.greeting();

const { greeting } = require("bar"); // 仅导入指定的 symbol
```

实际上可以将任意类型赋值给 `module.exports`，如 `class`

``` js
// file bar.js
class Logger {
    static debug(message) {
        console.log("DEBUG", message);
    }
}

// file foo.js
const Logger = require("./bar");
Logger.debug("hello, world!");
```


[`Node.js`](https://nodejs.org/) 默认支持 CommonJS Module，JavaScript ECMAScript(ES2015) 标准制定了标准的模块化规范 `ES Module`.

#### **ES Modules**

ES Module 也是以文件为单位作为模块，为了区别于 `.js` 文件默认作为 CommonJS Module, 规范定义 ES Module 文件的后缀名为 `.mjs`，实际实用一般仍用 `.js` 后缀，通过配置可自动识别文件使用的是那种 Module.

将前面的 Logger 改造成 ES Module 如下，

``` js
// bar.mjs
export default class Logger {
    static debug(message) {
        console.log("DEBUG", message);
    }
}

// 模块可以有一个 export default，但可以有多个其它 export 
export message = "Hello, world!";
export count = 42;

// 也可以集中导出
export { message, count };
```

通过 import 方式导入，

``` js
// foo.mjs
import Logger, { message, count } from "./bar";
Logger.debug("hello, world!");
Logger.debug(count);
Logger.debug(message);

// 当导入命名有冲突时，也可以重命名导入
import { default as BarLogger, message as defaultMessage, count} from "./bar";

// 导入成模块
import * as bar "./bar";
Logger.debug(bar.message);
```

#### **Dynamic vs. Static**

CommonJS 的 `requre()` 导入函数是在运行时动态解析导入的，也就是说 `require()` 可以像普通的函数那样使用，按需要导入，而 ES Module 的 `import` 是静态，在编译阶段就需要确定导入依赖，因些只能出现的文件头。

#### **index.js 与类型提示**

前面介绍的模块导入时，都是以文件名去掉后缀作为模块名，实际上也可以将文件夹名作为模块名（这可能也是为什么导入的时候不加文件名后缀的原因吧）

``` js
// 假设有文件夹 server 及其中的文件如下
// server
// ├── foo.js
// ├── bar.js
// ├── index.d.ts
// └── index.js
// 则将 index.js 作为 server 文件夹的默认模块导入如下
import * as server from "./server";
```

这种导入文件夹的方式有一个非常有用的地方在于可以在文夹中添加一个 index.d.ts 作为 index.js 中导出类型的定义 [Declartion Reference](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html)，辅助 IDE（如：VSCode）进行类型提示，而又不必采用 `TypeScript`，作为 JavaScript 动态类型的补充。另一方面，也可以在非 index.js 文件中定义非导出类型，统一在 index.js 文件中导出，将文件夹整体作为一个模块，就像 `package.json` 中导入的依赖一样。

### **package.json**

未完待续...